tippy('#how-to-wrangle-nested-data-using-the-tidyverse', {
    theme: 'light-border',
    arrow: false,
    allowHTML: true,
    placement: 'right',
    touch: false,
    maxWidth: 550,
    interactive: true,
    interactiveBorder: 1,
    content: '<div class="article-component"><h1>How to wrangle nested data using the tidyverse</h1><hr/><em>Last updated 2019-02-25</em><hr/><p>Most of my R training involved operations on dataframes, usually with <code class="language-plaintext highlighter-rouge">dplyr</code> functions like <code class="language-plaintext highlighter-rouge">filter</code>, <code class="language-plaintext highlighter-rouge">select</code>, <code class="language-plaintext highlighter-rouge">mutate</code>, <code class="language-plaintext highlighter-rouge">group_by</code>, and <code class="language-plaintext highlighter-rouge">summarize</code>. These are wonderful tools that I use every day. However, there is a second set of tools that have become equally important in my day-to-day data manipulation work in R: those for working with lists.</p><p>You may have been told on your first day learning R that a list is a special type of vector that can contain elements of different types, including lists. If you’re like me, you promptly forgot this fact, and spent the next year working with deliciously rectangular dataframes. But if you spend enough time working with data, it eventually becomes clear that most data isn’t born as a tidy CSV. Instead, it’s usually stored in a nested structure such as JSON or XML. That’s why lists are so useful in R. They are the most natural data type for representing a nested structure.</p><p>If <code class="language-plaintext highlighter-rouge">filter</code>, <code class="language-plaintext highlighter-rouge">select</code>, <code class="language-plaintext highlighter-rouge">mutate</code>, <code class="language-plaintext highlighter-rouge">group_by</code>, and <code class="language-plaintext highlighter-rouge">summarize</code> form my basic vocabulary for working with rectangular data, then <code class="language-plaintext highlighter-rouge">stringr::str_detect</code>, <code class="language-plaintext highlighter-rouge">jsonlite::fromJSON</code>, <code class="language-plaintext highlighter-rouge">magrittr::extract2</code>, and <code class="language-plaintext highlighter-rouge">purrr::map</code> form my basic vocabulary for working with nested data.</p><p>Say you’re working with telemetry data from a website. Your raw data probably comes out of a database looking something like this:</p><div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">tidyverse</span><span class="p">)</span><span class="w"></span><span class="n">library</span><span class="p">(</span><span class="n">magrittr</span><span class="p">)</span><span class="w"></span><span class="n">library</span><span class="p">(</span><span class="n">jsonlite</span><span class="p">)</span><span class="w"></span><span class="n">library</span><span class="p">(</span><span class="n">knitr</span><span class="p">)</span><span class="w"></span><span class="n">user_actions</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tibble</span><span class="p">(</span><span class="w">  </span><span class="n">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"david"</span><span class="p">,</span><span class="w"> </span><span class="s2">"david"</span><span class="p">,</span><span class="w"> </span><span class="s2">"david"</span><span class="p">,</span><span class="w"> </span><span class="s2">"david"</span><span class="p">,</span><span class="w"> </span><span class="s2">"david"</span><span class="p">,</span><span class="w"> </span><span class="s2">"david"</span><span class="p">),</span><span class="w">  </span><span class="n">action</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="w">    </span><span class="s1">'{"Type": "Login", "UtcTimestamp": "2019-03-05 12:30:41", "user": "david"}'</span><span class="p">,</span><span class="w">    </span><span class="s1">'{"Type": "ButtonPress", "UtcTimestamp": "2019-03-05 12:30:43", "ButtonID": "2kdkkdfl-jnsdol32", "ButtonName": "Settings"}'</span><span class="p">,</span><span class="w">    </span><span class="s1">'{"Type": "ToggleCheckbox", "UtcTimestamp": "2019-03-05 12:30:44", "CheckboxID": "5d2ddnn8-polen2e7", "CheckboxName": "Subscribe to email newsletter", "CheckboxStatus": "FALSE"}'</span><span class="p">,</span><span class="w">    </span><span class="s1">'{"Type": "ToggleCheckbox", "UtcTimestamp": "2019-03-05 12:30:45", "CheckboxID": "jjdfj133-883jdnb3", "CheckboxName": "Desktop notifications", "CheckboxStatus": "FALSE"}'</span><span class="p">,</span><span class="w">    </span><span class="s1">'{"Type": "ButtonPress", "UtcTimestamp": "2019-03-05 12:30:50", "ButtonID": "lop29cdk-4jns910d", "ButtonName": "Home"}'</span><span class="p">,</span><span class="w">    </span><span class="s1">'{"Type": "FollowLink", "UtcTimestamp": "2019-03-05 12:30:59", "URL": "https://www.theglobeandmail.com/"}'</span><span class="w">  </span><span class="p">)</span><span class="w"></span><span class="p">)</span><span class="w"></span><span class="n">user_actions</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">kable</span><span class="p">()</span><span class="w"></span></code></pre></div></div><table><thead><tr><th style="text-align: left">user</th><th style="text-align: left">action</th></tr></thead><tbody><tr><td style="text-align: left">david</td><td style="text-align: left">{“Type”: “Login”, “UtcTimestamp”: “2019-03-05 12:30:41”, “user”: “david”}</td></tr><tr><td style="text-align: left">david</td><td style="text-align: left">{“Type”: “ButtonPress”, “UtcTimestamp”: “2019-03-05 12:30:43”, “ButtonID”: “2kdkkdfl-jnsdol32”, “ButtonName”: “Settings”}</td></tr><tr><td style="text-align: left">david</td><td style="text-align: left">{“Type”: “ToggleCheckbox”, “UtcTimestamp”: “2019-03-05 12:30:44”, “CheckboxID”: “5d2ddnn8-polen2e7”, “CheckboxName”: “Subscribe to email newsletter”, “CheckboxStatus”: “FALSE”}</td></tr><tr><td style="text-align: left">david</td><td style="text-align: left">{“Type”: “ToggleCheckbox”, “UtcTimestamp”: “2019-03-05 12:30:45”, “CheckboxID”: “jjdfj133-883jdnb3”, “CheckboxName”: “Desktop notifications”, “CheckboxStatus”: “FALSE”}</td></tr><tr><td style="text-align: left">david</td><td style="text-align: left">{“Type”: “ButtonPress”, “UtcTimestamp”: “2019-03-05 12:30:50”, “ButtonID”: “lop29cdk-4jns910d”, “ButtonName”: “Home”}</td></tr><tr><td style="text-align: left">david</td><td style="text-align: left">{“Type”: “FollowLink”, “UtcTimestamp”: “2019-03-05 12:30:59”, “URL”: “<a href="https://www.theglobeandmail.com/">https://www.theglobeandmail.com/</a>”}</td></tr></tbody></table><p>Each logged event is a JSON string containing properties of the event. In my experience, the most common tasks for converting these nested structures into more legible rectangular structures are these:</p><h2 id="1-finding-all-events-of-a-particular-type">1. Finding all events of a particular type.</h2><p>Assuming that event types can be identified by the presence or absence of specific strings in the JSON, you can use <code class="language-plaintext highlighter-rouge">filter</code> along with <code class="language-plaintext highlighter-rouge">stringr::str_detect</code> to keep all rows of your events dataframe where the <code class="language-plaintext highlighter-rouge">action</code> string contains a pattern of interest. For example, say you want get all the <code class="language-plaintext highlighter-rouge">ToggleCheckbox</code> events.</p><div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user_actions</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">   </span><span class="n">filter</span><span class="p">(</span><span class="n">str_detect</span><span class="p">(</span><span class="n">action</span><span class="p">,</span><span class="w"> </span><span class="s2">"ToggleCheckbox"</span><span class="p">))</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">   </span><span class="n">kable</span><span class="p">()</span><span class="w"></span></code></pre></div></div><table><thead><tr><th style="text-align: left">user</th><th style="text-align: left">action</th></tr></thead><tbody><tr><td style="text-align: left">david</td><td style="text-align: left">{“Type”: “ToggleCheckbox”, “UtcTimestamp”: “2019-03-05 12:30:44”, “CheckboxID”: “5d2ddnn8-polen2e7”, “CheckboxName”: “Subscribe to email newsletter”, “CheckboxStatus”: “FALSE”}</td></tr><tr><td style="text-align: left">david</td><td style="text-align: left">{“Type”: “ToggleCheckbox”, “UtcTimestamp”: “2019-03-05 12:30:45”, “CheckboxID”: “jjdfj133-883jdnb3”, “CheckboxName”: “Desktop notifications”, “CheckboxStatus”: “FALSE”}</td></tr></tbody></table><h2 id="2-extracting-one-or-more-properties-from-an-event">2. Extracting one or more properties from an event.</h2><p>To extract a property from an event, you need to convert the event to a list and then index it. Let’s take the first <code class="language-plaintext highlighter-rouge">ToggleCheckbox</code> event as an example.</p><div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">first_toggle_checkbox_event</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">user_actions</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">   </span><span class="n">filter</span><span class="p">(</span><span class="n">str_detect</span><span class="p">(</span><span class="n">action</span><span class="p">,</span><span class="w"> </span><span class="s2">"ToggleCheckbox"</span><span class="p">))</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">   </span><span class="n">slice</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">   </span><span class="n">pull</span><span class="p">())</span><span class="w"></span></code></pre></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] "{\"Type\": \"ToggleCheckbox\", \"UtcTimestamp\": \"2019-03-05 12:30:44\", \"CheckboxID\": \"5d2ddnn8-polen2e7\", \"CheckboxName\": \"Subscribe to email newsletter\", \"CheckboxStatus\": \"FALSE\"}"</code></pre></div></div><p>We’ll use <code class="language-plaintext highlighter-rouge">jsonlite::fromJSON</code> to convert this string to a list, and then we’ll use <code class="language-plaintext highlighter-rouge">magrittr::extract2</code> to retrieve the <code class="language-plaintext highlighter-rouge">CheckboxName</code> property.</p><div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first_toggle_checkbox_event</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">   </span><span class="n">fromJSON</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">   </span><span class="n">extract2</span><span class="p">(</span><span class="s2">"CheckboxName"</span><span class="p">)</span><span class="w"></span></code></pre></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] "Subscribe to email newsletter"</code></pre></div></div><p>If you’ve never seen <code class="language-plaintext highlighter-rouge">extract2</code> before, it does the exact same thing as double square brackets, except that it takes the list as its first argument. This makes it very easy to use inside a chain of piped commands. (By contrast, <code class="language-plaintext highlighter-rouge">extract</code> does the same thing as single square brackets — usually not quite as useful.)</p><p>An alternative option is to use <code class="language-plaintext highlighter-rouge">%$%</code> — a <code class="language-plaintext highlighter-rouge">magrittr</code> infix function designed to work just like the standard pipe (<code class="language-plaintext highlighter-rouge">%&gt;%</code>) — except that the second argument is the name of the element to extract. For example, the code below is equivalent to the code above.</p><div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first_toggle_checkbox_event</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">   </span><span class="n">fromJSON</span><span class="p">()</span><span class="w"> </span><span class="o">%$%</span><span class="w">  </span><span class="n">CheckboxName</span><span class="w"></span></code></pre></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] "Subscribe to email newsletter"</code></pre></div></div><p>I prefer <code class="language-plaintext highlighter-rouge">extract2</code> because it feels a bit more explicit, but the second option is arguably more readable.</p><h2 id="3-operating-on-multiple-events-simultaneously">3. Operating on multiple events simultaneously.</h2><p>Lastly, you might wish to write an extraction function and map it across all events, regardless of their type. For this, you’ll want to pass <code class="language-plaintext highlighter-rouge">purrr::map</code> into <code class="language-plaintext highlighter-rouge">mutate</code>. For example, say we want to extract the timestamp from all events. We would start by writing a function to extract the <code class="language-plaintext highlighter-rouge">UtcTimestamp</code> field from a given event.</p><div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">extract_utc_timestamp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="n">event</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">     </span><span class="n">fromJSON</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">     </span><span class="n">extract2</span><span class="p">(</span><span class="s2">"UtcTimestamp"</span><span class="p">)</span><span class="w"></span><span class="p">}</span><span class="w"></span></code></pre></div></div><p>Our next step is to map this function across the values of the <code class="language-plaintext highlighter-rouge">action</code> column in our dataframe. You might wonder why it’s not possible to do the following:</p><div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user_actions</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">   </span><span class="n">mutate</span><span class="p">(</span><span class="n">utc_timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extract_utc_timestamp</span><span class="p">(</span><span class="n">action</span><span class="p">))</span><span class="w"></span></code></pre></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Error in mutate_impl(.data, dots): Evaluation error: parse error: trailing garbage##            12:30:41", "user": "david"} {"Type": "ButtonPress", "UtcTim##                      (right here) ------^## .</code></pre></div></div><p>The reason is that our function, <code class="language-plaintext highlighter-rouge">extract_utc_timestamp</code>, expects <code class="language-plaintext highlighter-rouge">event</code> to be a character vector of length 1. But <code class="language-plaintext highlighter-rouge">mutate</code> is passing in the entire character vector that is the <code class="language-plaintext highlighter-rouge">action</code> column. Unlike <code class="language-plaintext highlighter-rouge">sum</code> or <code class="language-plaintext highlighter-rouge">mean</code>, which can be passed into <code class="language-plaintext highlighter-rouge">mutate</code> with no issues, our function takes a single input and gives a single output.</p><p>If we want to apply this function across the whole set of values in the <code class="language-plaintext highlighter-rouge">action</code> column, we’ll need <code class="language-plaintext highlighter-rouge">map</code>, which does just that: it applies a function across a set of values and returns the resulting set of values. Now, <code class="language-plaintext highlighter-rouge">map</code> has a few variants depending on the desired class of the output; the default just returns a list. But in this case we want a character vector, so we’ll use <code class="language-plaintext highlighter-rouge">map_chr</code>.</p><div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user_actions</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">   </span><span class="n">mutate</span><span class="p">(</span><span class="w">    </span><span class="n">user_actions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_chr</span><span class="p">(</span><span class="w">      </span><span class="n">.x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">action</span><span class="p">,</span><span class="w">      </span><span class="n">.f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extract_utc_timestamp</span><span class="w">    </span><span class="p">)</span><span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">   </span><span class="n">kable</span><span class="p">()</span><span class="w"></span></code></pre></div></div><table><thead><tr><th style="text-align: left">user</th><th style="text-align: left">action</th><th style="text-align: left">user_actions</th></tr></thead><tbody><tr><td style="text-align: left">david</td><td style="text-align: left">{“Type”: “Login”, “UtcTimestamp”: “2019-03-05 12:30:41”, “user”: “david”}</td><td style="text-align: left">2019-03-05 12:30:41</td></tr><tr><td style="text-align: left">david</td><td style="text-align: left">{“Type”: “ButtonPress”, “UtcTimestamp”: “2019-03-05 12:30:43”, “ButtonID”: “2kdkkdfl-jnsdol32”, “ButtonName”: “Settings”}</td><td style="text-align: left">2019-03-05 12:30:43</td></tr><tr><td style="text-align: left">david</td><td style="text-align: left">{“Type”: “ToggleCheckbox”, “UtcTimestamp”: “2019-03-05 12:30:44”, “CheckboxID”: “5d2ddnn8-polen2e7”, “CheckboxName”: “Subscribe to email newsletter”, “CheckboxStatus”: “FALSE”}</td><td style="text-align: left">2019-03-05 12:30:44</td></tr><tr><td style="text-align: left">david</td><td style="text-align: left">{“Type”: “ToggleCheckbox”, “UtcTimestamp”: “2019-03-05 12:30:45”, “CheckboxID”: “jjdfj133-883jdnb3”, “CheckboxName”: “Desktop notifications”, “CheckboxStatus”: “FALSE”}</td><td style="text-align: left">2019-03-05 12:30:45</td></tr><tr><td style="text-align: left">david</td><td style="text-align: left">{“Type”: “ButtonPress”, “UtcTimestamp”: “2019-03-05 12:30:50”, “ButtonID”: “lop29cdk-4jns910d”, “ButtonName”: “Home”}</td><td style="text-align: left">2019-03-05 12:30:50</td></tr><tr><td style="text-align: left">david</td><td style="text-align: left">{“Type”: “FollowLink”, “UtcTimestamp”: “2019-03-05 12:30:59”, “URL”: “<a href="https://www.theglobeandmail.com/">https://www.theglobeandmail.com/</a>”}</td><td style="text-align: left">2019-03-05 12:30:59</td></tr></tbody></table><p>There you have it! With these four functions — <code class="language-plaintext highlighter-rouge">str_detect</code>, <code class="language-plaintext highlighter-rouge">fromJSON</code>, <code class="language-plaintext highlighter-rouge">extract2</code>, and <code class="language-plaintext highlighter-rouge">map</code> — you can perform all sorts of operations on large sets of nested data.</p></div>'
});